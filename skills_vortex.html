<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skills Vortex | Dark Hole Edition</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
        }

        #vortex-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Subtle core hint */
        .core-hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(147, 51, 234, 0.1) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1;
        }
    </style>
</head>

<body>
    <div class="core-hint"></div>
    <canvas id="vortex-canvas"></canvas>

    <script>
        /**
         * CINEMATIC DARK HOLE VORTEX
         * Improved visuals and logo reveal based on high-end portfolio reference.
         * Advanced blending for skills_atlas.png and coordinated absorption.
         */

        const canvas = document.getElementById('vortex-canvas');
        const ctx = canvas.getContext('2d');
        const ATLAS_URL = './skills_atlas.png';

        let width, height, centerX, centerY;
        let particles = [];
        let logos = [];
        let absorptionState = 0; // 0: Idle, 1: Absorbing, 2: Final
        let absorptionProgress = 0;
        let customCursor = { x: -100, y: -100, targetX: -100, targetY: -100 };
        let img = new Image();

        const IS_MOBILE = window.innerWidth <= 768;
        const PARTICLE_COUNT = IS_MOBILE ? 2500 : 6000;
        const LOGO_COUNT = 6;

        // Palette from reference: Whites to Deep Purples
        const PALETTE = [
            '255, 255, 255',   // Pure White
            '210, 200, 255',   // Cold White/Violet
            '167, 139, 250',   // Lite Purple
            '139, 92, 246',    // Purple
            '109, 40, 217'     // Mid Purple
        ];

        function sliceLogos(atlas) {
            const cols = 3;
            const rows = 2;
            const cellW = atlas.width / cols;
            const cellH = atlas.height / rows;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const offCanvas = document.createElement('canvas');
                    offCanvas.width = cellW;
                    offCanvas.height = cellH;
                    const offCtx = offCanvas.getContext('2d');

                    // Pre-process for matte blending: Black background + Screen composite
                    offCtx.fillStyle = '#000';
                    offCtx.fillRect(0, 0, cellW, cellH);
                    offCtx.globalCompositeOperation = 'screen';
                    offCtx.drawImage(atlas, c * cellW, r * cellH, cellW, cellH, 0, 0, cellW, cellH);

                    logos.push({
                        img: offCanvas,
                        opacity: 0,
                        scale: 2.2,     // Start over-scaled for the "pulling from horizon" effect
                        blur: 15,
                        rotation: Math.random() * Math.PI * 2,
                        revealed: false,
                        angle: (logos.length / LOGO_COUNT) * Math.PI * 2,
                        glowPulse: 0
                    });
                }
            }
        }

        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                this.angle = Math.random() * Math.PI * 2;
                // Cubic weighting near center to match reference density
                const spread = Math.max(width, height) * 0.6;
                this.radius = Math.pow(Math.random(), 2) * spread + 40;

                this.speed = (0.001 + Math.random() * 0.006) * (200 / this.radius);
                this.layer = Math.floor(Math.random() * 4);
                this.size = Math.random() * 1.5 + 0.3;
                this.alpha = (Math.random() * 0.4 + 0.1) * (1 - this.radius / spread);
                this.color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
            }

            update() {
                if (absorptionState === 1) {
                    this.radius *= 0.984;
                    this.angle += this.speed * 8 * (1 + absorptionProgress * 6);
                    if (this.radius < 5) this.alpha *= 0.8;
                } else if (absorptionState === 0) {
                    this.angle += this.speed * (1 + this.layer * 0.1);
                    // Slow inward spiral drift
                    this.radius -= this.speed * 1.5;
                    if (this.radius < 40) this.radius = Math.max(width, height) * 0.6;
                } else {
                    this.alpha *= 0.94;
                }

                this.x = centerX + Math.cos(this.angle) * this.radius;
                this.y = centerY + Math.sin(this.angle) * this.radius;
            }

            draw() {
                if (this.alpha < 0.01) return;
                ctx.fillStyle = `rgba(${this.color}, ${this.alpha})`;
                // Small squares match reference style
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        function init() {
            window.addEventListener('resize', onResize);
            onResize();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push(new Particle());
            }

            canvas.addEventListener('mousedown', handleClick);
            window.addEventListener('mousemove', (e) => {
                customCursor.targetX = e.clientX;
                customCursor.targetY = e.clientY;
            });

            animate();
        }

        function onResize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            centerX = width / 2;
            centerY = height / 2;
        }

        function handleClick(e) {
            if (absorptionState !== 0) return;
            const dx = e.clientX - centerX;
            const dy = e.clientY - centerY;
            if (Math.sqrt(dx * dx + dy * dy) < 70) startAbsorption();
        }

        function startAbsorption() {
            absorptionState = 1;
            const startTime = performance.now();
            const sequenceDuration = 12000;

            function runSequence() {
                const now = performance.now();
                absorptionProgress = Math.min((now - startTime) / sequenceDuration, 1);

                logos.forEach((logo, idx) => {
                    const stagger = 1400; // Time between each logo appearing
                    const delay = idx * stagger;
                    const elapsed = (now - startTime) - delay;

                    if (elapsed > 0) {
                        if (!logo.revealed) {
                            logo.revealed = true;
                            logo.glowPulse = 1;
                        }
                        // Pull transformation: shrink, clarify, lock
                        logo.opacity += (1 - logo.opacity) * 0.04;
                        logo.scale += (1 - logo.scale) * 0.04;
                        logo.blur += (0 - logo.blur) * 0.04;
                        logo.rotation += 0.003;
                        logo.glowPulse *= 0.92;
                    }
                });

                if (absorptionProgress < 1) requestAnimationFrame(runSequence);
                else absorptionState = 2; // Stabilized calm
            }
            requestAnimationFrame(runSequence);
        }

        function drawCursor() {
            // Smoothly interpolate cursor position
            customCursor.x += (customCursor.targetX - customCursor.x) * 0.15;
            customCursor.y += (customCursor.targetY - customCursor.y) * 0.15;

            // Simple glowing dot
            ctx.beginPath();
            ctx.arc(customCursor.x, customCursor.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();

            // Hover ring
            ctx.beginPath();
            ctx.arc(customCursor.x, customCursor.y, 16, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function animate() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, width, height);

            const corePulse = Math.sin(Date.now() / 600) * 3;
            const coreRad = 35 + corePulse;

            // Lens distortion effect (illusion)
            const lensRad = 65 + corePulse * 2;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.08 + Math.abs(corePulse) * 0.02})`;
            ctx.beginPath();
            ctx.arc(centerX, centerY, lensRad, 0, Math.PI * 2);
            ctx.stroke();

            // Core Glow
            const coreGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreRad * 2.2);
            coreGrad.addColorStop(0, '#fff');
            coreGrad.addColorStop(0.2, 'rgba(255, 255, 255, 0.9)');
            coreGrad.addColorStop(0.5, 'rgba(180, 200, 255, 0.2)');
            coreGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = coreGrad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreRad * 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Black Hole "Event Horizon"
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
            ctx.fill();

            particles.forEach(p => { p.update(); p.draw(); });

            if (absorptionState > 0) {
                const orbitRadius = Math.min(width, height) * (IS_MOBILE ? 0.38 : 0.33);
                logos.forEach(logo => {
                    if (logo.revealed) {
                        const lx = centerX + Math.cos(logo.angle) * orbitRadius;
                        const ly = centerY + Math.sin(logo.angle) * orbitRadius;
                        const baseSize = Math.min(width, height) * (IS_MOBILE ? 0.22 : 0.16);
                        const size = baseSize * logo.scale;

                        ctx.save();
                        ctx.translate(lx, ly);
                        ctx.rotate(logo.rotation);
                        ctx.globalAlpha = logo.opacity;

                        // Logo Glow Pulse
                        if (logo.glowPulse > 0.01) {
                            const pGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.8);
                            pGrad.addColorStop(0, `rgba(255, 255, 255, ${logo.glowPulse * 0.5})`);
                            pGrad.addColorStop(1, 'transparent');
                            ctx.fillStyle = pGrad;
                            ctx.beginPath();
                            ctx.arc(0, 0, size * 0.9, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Apply blur reveal effect
                        if (logo.blur > 0.5) {
                            ctx.filter = `blur(${logo.blur}px)`;
                        }

                        ctx.drawImage(logo.img, -size / 2, -size / 2, size, size);
                        ctx.filter = 'none';
                        ctx.restore();
                    }
                });
            }

            drawCursor();
            requestAnimationFrame(animate);
        }

        // Initialize atlas asset loading
        img.onload = () => {
            sliceLogos(img);
            init();
        };
        img.onerror = () => {
            console.error("Failed to load image atlas. Check the file path.");
        };
        img.src = ATLAS_URL;

        // Hide system cursor globally
        document.body.style.cursor = 'none';

    </script>
</body>

</html>